// Includes the header of this component
#include "maps_Path_Planner.h"

// Includes code header generated by the Real-Time Workshop
#include "Path_Planner.h"

//#if defined(_MSC_VER)
//    #pragma comment(lib, "shell32.lib")
//    #pragma comment(lib, "user32.lib")
//#endif
namespace                              /* struct input filters*/
{
}

MAPS_BEGIN_INPUTS_DEFINITION(ComponentClass)
// fifo ----------------------------------------------------------------------------------------
// sint
  MAPS_INPUT("i_fifo_int8" , MAPS::GetTypeFilter<int8_t >(), MAPS::FifoReader)
  MAPS_INPUT("i_fifo_int16", MAPS::GetTypeFilter<int16_t>(), MAPS::FifoReader)
  MAPS_INPUT("i_fifo_int32", MAPS::GetTypeFilter<int32_t>(), MAPS::FifoReader)
  MAPS_INPUT("i_fifo_int64", MAPS::GetTypeFilter<int64_t>(), MAPS::FifoReader)
// uint
  MAPS_INPUT("i_fifo_uint8" , MAPS::GetTypeFilter<uint8_t >(), MAPS::FifoReader)
  MAPS_INPUT("i_fifo_uint16", MAPS::GetTypeFilter<uint16_t>(), MAPS::FifoReader)
  MAPS_INPUT("i_fifo_uint32", MAPS::GetTypeFilter<uint32_t>(), MAPS::FifoReader)
  MAPS_INPUT("i_fifo_uint64", MAPS::GetTypeFilter<uint64_t>(), MAPS::FifoReader)
// f
  MAPS_INPUT("i_fifo_float32", MAPS::GetTypeFilter<float >(), MAPS::FifoReader)
  MAPS_INPUT("i_fifo_float64", MAPS::GetTypeFilter<double>(), MAPS::FifoReader)
// image
  MAPS_INPUT("i_fifo_iplimage", MAPS::GetTypeFilter<IplImage>(), MAPS::
             FifoReader)
// sampling ------------------------------------------------------------------------------------
// sint
  MAPS_INPUT("i_sampling_int8" , MAPS::GetTypeFilter<int8_t >(), MAPS::
             SamplingReader)
  MAPS_INPUT("i_sampling_int16", MAPS::GetTypeFilter<int16_t>(), MAPS::
             SamplingReader)
  MAPS_INPUT("i_sampling_int32", MAPS::GetTypeFilter<int32_t>(), MAPS::
             SamplingReader)
  MAPS_INPUT("i_sampling_int64", MAPS::GetTypeFilter<int64_t>(), MAPS::
             SamplingReader)
// uint
  MAPS_INPUT("i_sampling_uint8" , MAPS::GetTypeFilter<uint8_t >(), MAPS::
             SamplingReader)
  MAPS_INPUT("i_sampling_uint16", MAPS::GetTypeFilter<uint16_t>(), MAPS::
             SamplingReader)
  MAPS_INPUT("i_sampling_uint32", MAPS::GetTypeFilter<uint32_t>(), MAPS::
             SamplingReader)
  MAPS_INPUT("i_sampling_uint64", MAPS::GetTypeFilter<uint64_t>(), MAPS::
             SamplingReader)
// f
  MAPS_INPUT("i_sampling_float32", MAPS::GetTypeFilter<float >(), MAPS::
             SamplingReader)
  MAPS_INPUT("i_sampling_float64", MAPS::GetTypeFilter<double>(), MAPS::
             SamplingReader)
// image
  MAPS_INPUT("i_sampling_iplimage", MAPS::GetTypeFilter<IplImage>(), MAPS::
             SamplingReader)
// struct --------------------------------------------------------------------------------------
  MAPS_END_INPUTS_DEFINITION
  MAPS_BEGIN_OUTPUTS_DEFINITION(ComponentClass)
// sint
  MAPS_OUTPUT("o_int8" , MAPS::GetTypeInfoValue<int8_t >(), nullptr, nullptr, 0)
  MAPS_OUTPUT("o_int16", MAPS::GetTypeInfoValue<int16_t>(), nullptr, nullptr, 0)
  MAPS_OUTPUT("o_int32", MAPS::GetTypeInfoValue<int32_t>(), nullptr, nullptr, 0)
  MAPS_OUTPUT("o_int64", MAPS::GetTypeInfoValue<int64_t>(), nullptr, nullptr, 0)
// uint
  MAPS_OUTPUT("o_uint8" , MAPS::GetTypeInfoValue<uint8_t >(), nullptr, nullptr,
              0)
  MAPS_OUTPUT("o_uint16", MAPS::GetTypeInfoValue<uint16_t>(), nullptr, nullptr,
              0)
  MAPS_OUTPUT("o_uint32", MAPS::GetTypeInfoValue<uint32_t>(), nullptr, nullptr,
              0)
  MAPS_OUTPUT("o_uint64", MAPS::GetTypeInfoValue<uint64_t>(), nullptr, nullptr,
              0)
// f
  MAPS_OUTPUT("o_float32", MAPS::GetTypeInfoValue<float >(), nullptr, nullptr, 0)
  MAPS_OUTPUT("o_float64", MAPS::GetTypeInfoValue<double>(), nullptr, nullptr, 0)
// image
  MAPS_OUTPUT("o_iplimage", MAPS::GetTypeInfoValue<IplImage>(), nullptr, nullptr,
              0)
// struct --------------------------------------------------------------------------------------
  MAPS_END_OUTPUTS_DEFINITION
  MAPS_BEGIN_PROPERTIES_DEFINITION(ComponentClass)
  MAPS_PROPERTY_ENUM("executionMode",
                     "Periodic"
                     "|Triggered by First Input"
                     "|Periodic Sampling While Post-Processing",
                     0, false, false)
  MAPS_PROPERTY_READ_ONLY_SUBTYPE("executionPeriod", 0, MAPS::
  PropertySubTypeTime)
// model params
  MAPS_PROPERTY_BEGIN_SUBSECTION("p_model_params_begin", "model_parameters")
  MAPS_PROPERTY_END_SUBSECTION("p_model_params_end", true)
  MAPS_PROPERTY("p_bool", false, false, false)
  MAPS_PROPERTY("p_string", "", false, false)
// default input values
  MAPS_PROPERTY_BEGIN_SUBSECTION("p_input_values_begin", "input_values")
  MAPS_PROPERTY_END_SUBSECTION("p_input_values_end", true)
  MAPS_PROPERTY("p_force_value_of_input", false, false, false)
  MAPS_PROPERTY("p_value_of_input", "0", false, false)
     /* 0 by default in order to have a valid initial value for parseValues() */
  MAPS_END_PROPERTIES_DEFINITION
  MAPS_BEGIN_ACTIONS_DEFINITION(ComponentClass)
//MAPS_ACTION("aName",ComponentClass::ActionName)
  MAPS_END_ACTIONS_DEFINITION
  MAPS_COMPONENT_DEFINITION_REGISTRATION(ComponentClass,ComponentName,
  ComponentVersion,128,MAPS::Threaded,MAPS::Threaded,
  0,                                   // inputs
  0,                                   // outputs
  1,                                   // properties
  0)                                   // actions
  namespace
{

#define TypeID(type)                   TypeID_Wrapper<type>::value

  template <typename T, typename TSize = int>
  struct RowMajorMatrixView
  {
    T* m_data;
    const TSize m_rowCount;
    const TSize m_colCount;
    RowMajorMatrixView(T* data, const TSize rowCount, const TSize colCount)
      : m_data(data), m_rowCount(rowCount), m_colCount(colCount)
    {
    }

    T& operator()(const TSize row, const TSize col)
    {
      return m_data[ (row * m_colCount) + col ];
    }

    RowMajorMatrixView<T, TSize>& operator= (const RowMajorMatrixView<T, TSize>&
      other)
    {
      m_data = other.m_data;
      m_rowCount = other.m_rowCount;
      m_colCount = other.m_colCount;
      return *this;
    }
  };

  template <typename T, typename TSize = int>
      struct ColMajorMatrixView
  {
    T* m_data;
    const TSize m_rowCount;
    const TSize m_colCount;
    ColMajorMatrixView(T* data, const TSize rowCount, const TSize colCount)
      : m_data(data), m_rowCount(rowCount), m_colCount(colCount)
    {
    }

    T& operator()(const TSize row, const TSize col)
    {
      return m_data[ (col * m_rowCount) + row ];
    }

    ColMajorMatrixView<T, TSize>& operator= (const ColMajorMatrixView<T, TSize>&
      other)
    {
      m_data = other.m_data;
      m_rowCount = other.m_rowCount;
      m_colCount = other.m_colCount;
      return *this;
    }
  };

  template <typename TComponentIOInfo>
    std::string getIOModelName(const TComponentIOInfo& info)
  {
    static_assert(
                  std::is_same<TComponentIOInfo, ComponentInputInfo >::value ||
                  std::is_same<TComponentIOInfo, ComponentOutputInfo>::value,
                  "Wrong template argument. Expected ComponentInputInfo or ComponentOutputInfo"
                  );
    switch (info.m_typeId)
    {
     case TypeID(int8_t ):
      return "int8" ;

     case TypeID(int16_t ):
      return "int16" ;

     case TypeID(int32_t ):
      return "int32" ;

     case TypeID(int64_t ):
      return "int64" ;

     case TypeID(uint8_t ):
      return "uint8" ;

     case TypeID(uint16_t):
      return "uint16" ;

     case TypeID(uint32_t):
      return "uint32" ;

     case TypeID(uint64_t):
      return "uint64" ;

     case TypeID(float ):
      return "float32";

     case TypeID(double ):
      return "float64";

     case TypeID(IplImage):
      return "iplimage";

     case TypeID(Struct_t):
      return info.m_data->m_skTypeName;

     default:
      MAPS::ReportError(MAPSStreamedString() << MAPS_FUNCTION_SIGNATURE <<
                        ": Unsupported I/O Type ID [info_id:" << info.m_typeId <<
                        "]");
      throw MAPS::ErrorException;
    }
  }

  bool hasSuffix(const std::string& str, const std::string& suffix)
  {
    if (str.length() >= suffix.length()) {
      return str.compare(str.length() - suffix.length(), suffix.length(), suffix)
        == 0;
    } else {
      return false;
    }
  }

  std::string removeSuffix(const std::string& str, const std::string& suffix)
  {
    return str.substr(0, str.size() - suffix.size());
  }

  std::string extractIOBaseName(const std::string& name)
  {
    if (hasSuffix(name, G_IO_SUFFIX_VECTOR_SIZE)) {
      return removeSuffix(name, G_IO_SUFFIX_VECTOR_SIZE);
    } else if (hasSuffix(name, G_IO_SUFFIX_TIMESTAMP )) {
      return removeSuffix(name, G_IO_SUFFIX_TIMESTAMP );
    } else if (hasSuffix(name, G_IO_SUFFIX_FREQUENCY )) {
      return removeSuffix(name, G_IO_SUFFIX_FREQUENCY );
    } else if (hasSuffix(name, G_IO_SUFFIX_QUALITY )) {
      return removeSuffix(name, G_IO_SUFFIX_QUALITY );
    } else if (hasSuffix(name, G_IO_SUFFIX_MISC1 )) {
      return removeSuffix(name, G_IO_SUFFIX_MISC1 );
    } else if (hasSuffix(name, G_IO_SUFFIX_MISC2 )) {
      return removeSuffix(name, G_IO_SUFFIX_MISC2 );
    } else if (hasSuffix(name, G_IO_SUFFIX_MISC3 )) {
      return removeSuffix(name, G_IO_SUFFIX_MISC3 );
    }

    // For IplImages, the base name is indeed "PortName_IplImage"
    else if (hasSuffix(name, G_IO_SUFFIX_IPLIMAGE )) {
      return name;
    } else if (hasSuffix(name, G_IO_SUFFIX_IPLIMAGE_SIZE )) {
      return removeSuffix(name, G_IO_SUFFIX_IPLIMAGE_SIZE ) +
        G_IO_SUFFIX_IPLIMAGE;
    } else if (hasSuffix(name, G_IO_SUFFIX_IPLIMAGE_CHANNEL_SEQ)) {
      return removeSuffix(name, G_IO_SUFFIX_IPLIMAGE_CHANNEL_SEQ) +
        G_IO_SUFFIX_IPLIMAGE;
    }

    //else if (hasSuffix(name, G_IO_SUFFIX_IPLIMAGE_DATA_ORDER )) { return removeSuffix(name, G_IO_SUFFIX_IPLIMAGE_DATA_ORDER ) + G_IO_SUFFIX_IPLIMAGE; }
    //else if (hasSuffix(name, G_IO_SUFFIX_IPLIMAGE_DEPTH      )) { return removeSuffix(name, G_IO_SUFFIX_IPLIMAGE_DEPTH      ) + G_IO_SUFFIX_IPLIMAGE; }
    //else if (hasSuffix(name, G_IO_SUFFIX_IPLIMAGE_ALIGN      )) { return removeSuffix(name, G_IO_SUFFIX_IPLIMAGE_ALIGN      ) + G_IO_SUFFIX_IPLIMAGE; }
    else {
      return name;
    }
  }

  template <typename TComponentIOInfo>
    TComponentIOInfo& getByBaseNameOrInsert(std::vector<TComponentIOInfo>
    & compIo, const std::string& baseName)
  {
    auto it = std::find_if(compIo.begin(), compIo.end(), [&] (const
      TComponentIOInfo& io)
    {
      return io.m_name == baseName;
    }

    );
    if (it != compIo.end()) {
      return *it;
    } else {
      compIo.emplace_back(baseName);
      return compIo.back();
    }
  }

  template <typename T, typename Alloc, typename Pred>
    void eraseRemoveIf(std::vector<T, Alloc>& v, const Pred& pred)
  {
    v.erase(std::remove_if(v.begin(), v.end(), pred), v.end());
  }

  template <typename TSrc, typename TDst>
    typename std::enable_if<
    std::is_same<TSrc, TDst>::value
    >::type copyData(const TSrc& src, TDst& dst)
  {
    dst = src;
  }

  template <typename TSrc, typename TDst>
    typename std::enable_if<
    !std::is_same<TSrc, TDst>::value &&
    !std::is_same<TSrc, bool>::value &&
    !std::is_same<TDst, bool>::value
    >::type copyData(const TSrc& src, TDst& dst)
  {
    dst = static_cast<TDst>(src);
  }

  template <typename TSrc>
    typename std::enable_if<
    !std::is_same<TSrc, bool>::value
    >::type copyData(const TSrc& src, bool& dst)
  {
    dst = (src != 0);
  }

  template <typename TDst>
    typename std::enable_if<
    !std::is_same<TDst, bool>::value
    >::type copyData(const bool& src, TDst& dst)
  {
    dst = static_cast<TDst>(src ? 1 : 0);
  }

  template <typename TSrc, typename TDst>
    typename std::enable_if<
    std::is_same<TSrc, TDst>::value
    >::type copyData(const TSrc* src, TDst* dst, const size_t elementCount)
  {
    std::memcpy(dst, src, elementCount * sizeof(TSrc));
  }

  template <typename TSrc, typename TDst>
    typename std::enable_if<
    !std::is_same<TSrc, TDst>::value
    >::type copyData(const TSrc* src, TDst* dst, const size_t elementCount)
  {
    for (size_t idx = 0; idx < elementCount; ++idx) {
      copyData(src[idx], dst[idx]);
    }
  }

  template <typename TDst>
    typename std::enable_if<
    !std::is_void<TDst>::value
    >::type copyData(const TypeID_Value srcVoidPtrTypeId, const void* src, TDst*
                     dst, const size_t elementCount)
  {
    switch (srcVoidPtrTypeId)
    {
     case TypeID(double ):
      copyData(static_cast<const double *>(src), dst, elementCount);
      break;

     case TypeID(float ):
      copyData(static_cast<const float *>(src), dst, elementCount);
      break;

     case TypeID(int8_t ):
      copyData(static_cast<const int8_t *>(src), dst, elementCount);
      break;

     case TypeID(uint8_t ):
      copyData(static_cast<const uint8_t *>(src), dst, elementCount);
      break;

     case TypeID(int16_t ):
      copyData(static_cast<const int16_t *>(src), dst, elementCount);
      break;

     case TypeID(uint16_t):
      copyData(static_cast<const uint16_t*>(src), dst, elementCount);
      break;

     case TypeID(int32_t ):
      copyData(static_cast<const int32_t *>(src), dst, elementCount);
      break;

     case TypeID(uint32_t):
      copyData(static_cast<const uint32_t*>(src), dst, elementCount);
      break;

     case TypeID(int64_t ):
      copyData(static_cast<const int64_t *>(src), dst, elementCount);
      break;

     case TypeID(uint64_t):
      copyData(static_cast<const uint64_t*>(src), dst, elementCount);
      break;

     case TypeID(bool ):
      copyData(static_cast<const bool *>(src), dst, elementCount);
      break;

     default:
      MAPS::ReportError(MAPSStreamedString() << MAPS_FUNCTION_SIGNATURE <<
                        ": Unknown Type ID [src_type_id:" << srcVoidPtrTypeId <<
                        "]");
      throw MAPS::ErrorException;
    }
  }

  template <typename TSrc>
    typename std::enable_if<
    !std::is_void<TSrc>::value
    >::type copyData(const TypeID_Value dstVoidPtrTypeId, const TSrc* src, void*
                     dst, const size_t elementCount)
  {
    switch (dstVoidPtrTypeId)
    {
     case TypeID(double ):
      copyData(src, static_cast<double *>(dst), elementCount);
      break;

     case TypeID(float ):
      copyData(src, static_cast<float *>(dst), elementCount);
      break;

     case TypeID(int8_t ):
      copyData(src, static_cast<int8_t *>(dst), elementCount);
      break;

     case TypeID(uint8_t ):
      copyData(src, static_cast<uint8_t *>(dst), elementCount);
      break;

     case TypeID(int16_t ):
      copyData(src, static_cast<int16_t *>(dst), elementCount);
      break;

     case TypeID(uint16_t):
      copyData(src, static_cast<uint16_t*>(dst), elementCount);
      break;

     case TypeID(int32_t ):
      copyData(src, static_cast<int32_t *>(dst), elementCount);
      break;

     case TypeID(uint32_t):
      copyData(src, static_cast<uint32_t*>(dst), elementCount);
      break;

     case TypeID(int64_t ):
      copyData(src, static_cast<int64_t *>(dst), elementCount);
      break;

     case TypeID(uint64_t):
      copyData(src, static_cast<uint64_t*>(dst), elementCount);
      break;

     case TypeID(bool ):
      copyData(src, static_cast<bool *>(dst), elementCount);
      break;

     default:
      MAPS::ReportError(MAPSStreamedString() << MAPS_FUNCTION_SIGNATURE <<
                        ": Unknown Type ID [dst_type_id:" << dstVoidPtrTypeId <<
                        "]");
      throw MAPS::ErrorException;
    }
  }

  template <typename TData>
    void writeToModelInput(const ModelInputInfo* skInput, const TData* data,
    const size_t elementCount)
  {
    if (skInput != nullptr) {
      skInput->m_writeToModelInput(TypeID(TData), data, elementCount);
    }
  }

  template <typename TData>
    void writeToModelInput(const ModelInputInfo* skInput, const TData& data)
  {
    writeToModelInput(skInput, &data, 1);
  }

  template <typename TData, typename TDefaultData>
    void readFromModelOutput(const ModelOutputInfo* skOutput, TData& data, const
    TDefaultData& defaultValue)
  {
    if (skOutput != nullptr) {
      skOutput->m_readFromModelOutput(TypeID(TData), &data, 1);
    } else {
      data = static_cast<TData>(defaultValue);
    }
  }

  template <SkTypeId skTypeID, typename T>
    typename std::enable_if<
    skTypeID != SkTypeId::t_bool,
    bool
    >::type parseData(MAPSProperty& mapsProp, T& val)
  {
    char* propertyLocale = MAPSIconv::UTF8ToLocale(mapsProp.StringValue());
    std::string stringVal(propertyLocale);
    MAPSIconv::releaseLocale(propertyLocale);
    if (stringVal == "") {
      return false;
    }

    std::istringstream iss{ stringVal };

    return static_cast<bool>(iss >> val);
  }

  template <SkTypeId skTypeID, typename T>
    typename std::enable_if<
    skTypeID == SkTypeId::t_bool,
    bool
    >::type parseData(MAPSProperty& mapsProp, T& val)
  {
    val = mapsProp.BoolValue() ? 1 : 0;
    return true;
  }

  template <typename T>
    size_t parseValues(const std::string& valuesStr, std::vector<unsigned char>&
                       rawValues)
  {
    rawValues.clear();
    std::istringstream iss{ valuesStr };

    std::vector<T> parsedValues;
    T val{ };

    while (static_cast<bool>(iss >> val)) {
      parsedValues.emplace_back(val);
    }

    const size_t parsedValueCount = parsedValues.size();
    const size_t parsedByteCount = parsedValueCount * sizeof(T);
    rawValues.resize(parsedByteCount);
    std::memcpy(rawValues.data(), parsedValues.data(), parsedByteCount);
    return parsedValueCount;
  }
}
// allow only a single instance of the component
// this limitation might be removed in a future version
ComponentClass* ComponentClass::s_instance = nullptr;

std::mutex ComponentClass::s_instanceMutex;

//
std::vector<ModelInputInfo> ComponentClass::s_skModelInputs;
std::vector<ModelOutputInfo> ComponentClass::s_skModelOutputs;
std::vector<ModelParamInfo> ComponentClass::s_skModelParams;

//
std::vector<ComponentInputInfo> ComponentClass::s_componentInputs;
std::vector<ComponentOutputInfo> ComponentClass::s_componentOutputs;

//
const MAPSDelay ComponentClass::s_skModelStepSize = static_cast<MAPSDelay>
  (1000000.0 * 0.01);
void ComponentClass::computeSkModelInputs()
{
  s_skModelInputs.clear();
  s_skModelInputs.reserve(G_MODEL_INPUT_COUNT);
  s_skModelInputs.emplace_back(
    "VehSpdAvrgDrvn_kmph",
    0,
    1,
    SkTypeId::t_double,
    "real_T",
    static_cast<int>(sizeof( real_T )),
    &Path_Planner_U.VehSpdAvrgDrvn_kmph,
    [] (const TypeID_Value mapsTypeId, const void* mapsInPtr, const size_t
        elementCount)
  {
    copyData(
             mapsTypeId,
             mapsInPtr,
             &Path_Planner_U.VehSpdAvrgDrvn_kmph,
             elementCount
             );
  }

  );
  s_skModelInputs.emplace_back(
    "SetSpeed_kmph",
    1,
    1,
    SkTypeId::t_double,
    "real_T",
    static_cast<int>(sizeof( real_T )),
    &Path_Planner_U.SetSpeed_kmph,
    [] (const TypeID_Value mapsTypeId, const void* mapsInPtr, const size_t
        elementCount)
  {
    copyData(
             mapsTypeId,
             mapsInPtr,
             &Path_Planner_U.SetSpeed_kmph,
             elementCount
             );
  }

  );
  s_skModelInputs.emplace_back(
    "LdCrCount_num",
    2,
    1,
    SkTypeId::t_double,
    "real_T",
    static_cast<int>(sizeof( real_T )),
    &Path_Planner_U.LdCrCount_num,
    [] (const TypeID_Value mapsTypeId, const void* mapsInPtr, const size_t
        elementCount)
  {
    copyData(
             mapsTypeId,
             mapsInPtr,
             &Path_Planner_U.LdCrCount_num,
             elementCount
             );
  }

  );
  s_skModelInputs.emplace_back(
    "LdCrLongDist_m",
    3,
    1,
    SkTypeId::t_double,
    "real_T",
    static_cast<int>(sizeof( real_T )),
    &Path_Planner_U.LdCrLongDist_m,
    [] (const TypeID_Value mapsTypeId, const void* mapsInPtr, const size_t
        elementCount)
  {
    copyData(
             mapsTypeId,
             mapsInPtr,
             &Path_Planner_U.LdCrLongDist_m,
             elementCount
             );
  }

  );
  s_skModelInputs.emplace_back(
    "LdCrLongSpd_kmph",
    4,
    1,
    SkTypeId::t_double,
    "real_T",
    static_cast<int>(sizeof( real_T )),
    &Path_Planner_U.LdCrLongSpd_kmph,
    [] (const TypeID_Value mapsTypeId, const void* mapsInPtr, const size_t
        elementCount)
  {
    copyData(
             mapsTypeId,
             mapsInPtr,
             &Path_Planner_U.LdCrLongSpd_kmph,
             elementCount
             );
  }

  );
}

void ComponentClass::computeSkModelOutputs()
{
  s_skModelOutputs.clear();
  s_skModelOutputs.reserve(G_MODEL_OUTPUT_COUNT);
  s_skModelOutputs.emplace_back(
    "TrgtSpd_kmph",
    0,
    1,
    SkTypeId::t_double,
    "real_T",
    static_cast<int>(sizeof( real_T )),
    &Path_Planner_Y.TrgtSpd_kmph,
    [] (const TypeID_Value mapsTypeId, void* mapsOutPtr, const size_t
        elementCount)
  {
    copyData(
             mapsTypeId,
             &Path_Planner_Y.TrgtSpd_kmph,
             mapsOutPtr,
             elementCount
             );
  }

  );
  s_skModelOutputs.emplace_back(
    "RelDist_m",
    1,
    1,
    SkTypeId::t_double,
    "real_T",
    static_cast<int>(sizeof( real_T )),
    &Path_Planner_Y.RelDist_m,
    [] (const TypeID_Value mapsTypeId, void* mapsOutPtr, const size_t
        elementCount)
  {
    copyData(
             mapsTypeId,
             &Path_Planner_Y.RelDist_m,
             mapsOutPtr,
             elementCount
             );
  }

  );
  s_skModelOutputs.emplace_back(
    "RelSpd_kmph",
    2,
    1,
    SkTypeId::t_double,
    "real_T",
    static_cast<int>(sizeof( real_T )),
    &Path_Planner_Y.RelSpd_kmph,
    [] (const TypeID_Value mapsTypeId, void* mapsOutPtr, const size_t
        elementCount)
  {
    copyData(
             mapsTypeId,
             &Path_Planner_Y.RelSpd_kmph,
             mapsOutPtr,
             elementCount
             );
  }

  );
  s_skModelOutputs.emplace_back(
    "IntdToStp_bool",
    3,
    1,
    SkTypeId::t_double,
    "real_T",
    static_cast<int>(sizeof( real_T )),
    &Path_Planner_Y.IntdToStp_bool,
    [] (const TypeID_Value mapsTypeId, void* mapsOutPtr, const size_t
        elementCount)
  {
    copyData(
             mapsTypeId,
             &Path_Planner_Y.IntdToStp_bool,
             mapsOutPtr,
             elementCount
             );
  }

  );
  s_skModelOutputs.emplace_back(
    "TrgtDist_m",
    4,
    1,
    SkTypeId::t_double,
    "real_T",
    static_cast<int>(sizeof( real_T )),
    &Path_Planner_Y.TrgtDist_m,
    [] (const TypeID_Value mapsTypeId, void* mapsOutPtr, const size_t
        elementCount)
  {
    copyData(
             mapsTypeId,
             &Path_Planner_Y.TrgtDist_m,
             mapsOutPtr,
             elementCount
             );
  }

  );
}

void ComponentClass::computeSkModelProps()
{
  s_skModelParams.clear();
  s_skModelParams.reserve(G_MODEL_PARAM_COUNT);
  s_skModelParams.emplace_back(
    "Constant_Value",
    0,
    1,
    SkTypeId::t_double,
    "1.0",
    &Path_Planner_P.Constant_Value,
    [] (MAPSProperty& mapsProp) -> bool {
    return parseData< SkTypeId::t_double >(mapsProp,
    Path_Planner_P.Constant_Value);
  }
  );

  s_skModelParams.emplace_back(
    "cacc_override_dist_m_Value",
    1,
    1,
    SkTypeId::t_double,
    "-1.0",
    &Path_Planner_P.cacc_override_dist_m_Value,
    [] (MAPSProperty& mapsProp) -> bool {
    return parseData< SkTypeId::t_double >(mapsProp,
    Path_Planner_P.cacc_override_dist_m_Value);
  }
  );

  s_skModelParams.emplace_back(
    "Gain_Gain",
    2,
    1,
    SkTypeId::t_double,
    "-1.0",
    &Path_Planner_P.Gain_Gain,
    [] (MAPSProperty& mapsProp) -> bool {
    return parseData< SkTypeId::t_double >(mapsProp, Path_Planner_P.Gain_Gain);
  }
  );

  s_skModelParams.emplace_back(
    "cacc_dist_offset_m_Value",
    3,
    1,
    SkTypeId::t_double,
    "8.0",
    &Path_Planner_P.cacc_dist_offset_m_Value,
    [] (MAPSProperty& mapsProp) -> bool {
    return parseData< SkTypeId::t_double >(mapsProp,
    Path_Planner_P.cacc_dist_offset_m_Value);
  }
  );

  s_skModelParams.emplace_back(
    "cacc_time_gap_sec_Value",
    4,
    1,
    SkTypeId::t_double,
    "3.0",
    &Path_Planner_P.cacc_time_gap_sec_Value,
    [] (MAPSProperty& mapsProp) -> bool {
    return parseData< SkTypeId::t_double >(mapsProp,
    Path_Planner_P.cacc_time_gap_sec_Value);
  }
  );

  s_skModelParams.emplace_back(
    "kmph_mps_converter_Gain",
    5,
    1,
    SkTypeId::t_double,
    "0.27777777777777779",
    &Path_Planner_P.kmph_mps_converter_Gain,
    [] (MAPSProperty& mapsProp) -> bool {
    return parseData< SkTypeId::t_double >(mapsProp,
    Path_Planner_P.kmph_mps_converter_Gain);
  }
  );
}

template <typename TSkModelIOInfo, typename TComponentIOInfo>
  void ComponentClass::computeComponentIO(const TSkModelIOInfo& modelIo,
  TComponentIOInfo& compIo)
{
  const std::string& name = modelIo.m_name;
  const auto initImageInfo = [&] {
    if (compIo.m_typeId != TypeID(IplImage))
    {
      compIo.m_typeId = TypeID(IplImage);
      compIo.m_imageInfo = decltype(compIo.m_imageInfo)
      {
      }

      ;
    }
  };

  // common meta infos
  if (hasSuffix(name, G_IO_SUFFIX_VECTOR_SIZE)) {
    compIo.m_vectorSize = &modelIo;
  } else if (hasSuffix(name, G_IO_SUFFIX_TIMESTAMP )) {
    compIo.m_timestamp = &modelIo;
  } else if (hasSuffix(name, G_IO_SUFFIX_FREQUENCY )) {
    compIo.m_frequency = &modelIo;
  } else if (hasSuffix(name, G_IO_SUFFIX_QUALITY )) {
    compIo.m_quality = &modelIo;
  } else if (hasSuffix(name, G_IO_SUFFIX_MISC1 )) {
    compIo.m_misc1 = &modelIo;
  } else if (hasSuffix(name, G_IO_SUFFIX_MISC2 )) {
    compIo.m_misc2 = &modelIo;
  } else if (hasSuffix(name, G_IO_SUFFIX_MISC3 )) {
    compIo.m_misc3 = &modelIo;
  }

  // ipl image
  else if (hasSuffix(name, G_IO_SUFFIX_IPLIMAGE)) {
    initImageInfo();
    compIo.m_data = &modelIo;
  } else if (hasSuffix(name, G_IO_SUFFIX_IPLIMAGE_SIZE )) {
    initImageInfo();
    compIo.m_imageInfo.m_size = &modelIo;
  } else if (hasSuffix(name, G_IO_SUFFIX_IPLIMAGE_CHANNEL_SEQ)) {
    initImageInfo();
    compIo.m_imageInfo.m_channelSeq = &modelIo;
  }

  //else if (hasSuffix(name, G_IO_SUFFIX_IPLIMAGE_DATA_ORDER )) { initImageInfo(); compIo.m_imageInfo.m_dataOrder  = &modelIo; }
  //else if (hasSuffix(name, G_IO_SUFFIX_IPLIMAGE_DEPTH      )) { initImageInfo(); compIo.m_imageInfo.m_depth      = &modelIo; }
  //else if (hasSuffix(name, G_IO_SUFFIX_IPLIMAGE_ALIGN      )) { initImageInfo(); compIo.m_imageInfo.m_align      = &modelIo; }
  else                                 // numeric data: int, float, bool, struct
  {
    compIo.m_data = &modelIo;
    compIo.m_typeId = [&] {
      switch (modelIo.m_skTypeId)
      {
        case SkTypeId::t_double: return TypeID(double );

       case SkTypeId::t_single:
        return TypeID(float );

       case SkTypeId::t_int8 :
        return TypeID(int8_t );

       case SkTypeId::t_uint8 :
        return TypeID(uint8_t );

       case SkTypeId::t_int16 :
        return TypeID(int16_t );

       case SkTypeId::t_uint16:
        return TypeID(uint16_t);

       case SkTypeId::t_int32 :
        return TypeID(int32_t );

       case SkTypeId::t_uint32:
        return TypeID(uint32_t);

       case SkTypeId::t_bool :
        return TypeID(int32_t );
                            // int32 is used to represent bools on component I/O

       case SkTypeId::t_struct:
        return TypeID(Struct_t);

       default:
        MAPS::ReportError(MAPSStreamedString() << MAPS_FUNCTION_SIGNATURE <<
                          ": Unsupported Simulink I/O Type [sk_type_id:" <<
                          static_cast<int>(modelIo.m_skTypeId) << "]");
        throw MAPS::ErrorException;
      }
    }();
  }
}

template <typename TComponentIOInfo>
  void ComponentClass::filterComponentIOs(std::vector<TComponentIOInfo>& compIos)
{
  // filter out the I/Os that don't have "data"
  {
    for (const auto& compIo : compIos) {
      if (compIo.m_data == nullptr) {
        MAPS::ReportWarning(MAPSStreamedString() <<
                            "No data connection found for I/O port [" <<
                            compIo.m_name.c_str() << "]");
      }
    }

    eraseRemoveIf(compIos, [] (const TComponentIOInfo& io)
                  {
                  return io.m_data == nullptr;
                  }

                  );
  }

  // filter out the ipl image ios that don't have all the required meta info
  {
    for (const auto& compIo : compIos) {
      if (compIo.m_typeId == TypeID(IplImage)) {
        auto& imageInfo = compIo.m_imageInfo;
        if (imageInfo.m_size == nullptr) {
          MAPS::ReportWarning(MAPSStreamedString() << "Port '" << removeSuffix
                              (compIo.m_name, G_IO_SUFFIX_IPLIMAGE).c_str() <<
                              G_IO_SUFFIX_IPLIMAGE_SIZE << "' not found");
        }

        if (imageInfo.m_channelSeq == nullptr) {
          MAPS::ReportWarning(MAPSStreamedString() << "Port '" << removeSuffix
                              (compIo.m_name, G_IO_SUFFIX_IPLIMAGE).c_str() <<
                              G_IO_SUFFIX_IPLIMAGE_CHANNEL_SEQ << "' not found");
        }

        //if (imageInfo.m_dataOrder  == nullptr) { MAPS::ReportWarning(MAPSStreamedString() << "Port '" << removeSuffix(compIo.m_name, G_IO_SUFFIX_IPLIMAGE).c_str() << G_IO_SUFFIX_IPLIMAGE_DATA_ORDER  << "' not found"); }
        //if (imageInfo.m_depth      == nullptr) { MAPS::ReportWarning(MAPSStreamedString() << "Port '" << removeSuffix(compIo.m_name, G_IO_SUFFIX_IPLIMAGE).c_str() << G_IO_SUFFIX_IPLIMAGE_DEPTH       << "' not found"); }
        //if (imageInfo.m_align      == nullptr) { MAPS::ReportWarning(MAPSStreamedString() << "Port '" << removeSuffix(compIo.m_name, G_IO_SUFFIX_IPLIMAGE).c_str() << G_IO_SUFFIX_IPLIMAGE_ALIGN       << "' not found"); }
      }
    }

    eraseRemoveIf(compIos, [] (const TComponentIOInfo& io)
                  {
                  if (io.m_typeId == TypeID(IplImage)) {
                  const auto& imageInfo = io.m_imageInfo;
                  return (imageInfo.m_size == nullptr)
                  || (imageInfo.m_channelSeq == nullptr)
        //|| (imageInfo.m_dataOrder  == nullptr)
        //|| (imageInfo.m_depth      == nullptr)
        //|| (imageInfo.m_align      == nullptr)
                  ;
                  } else {
                  return false;
                  }
                  }

                  );
  }
}

template <typename TSkModelIOInfo, typename TComponentIOInfo>
  void ComponentClass::computeComponentIOs(const std::vector<TSkModelIOInfo>
  & modelIos, std::vector<TComponentIOInfo>& compIos)
{
  compIos.clear();
  if (modelIos.empty()) {
    MAPS::ReportError("modelIos is empty");
    throw MAPS::ErrorException;
  }

  // find out the role of each i/o
  for (const auto& modelIo : modelIos) {
    const auto baseName = extractIOBaseName(modelIo.m_name);
    auto& compIo = getByBaseNameOrInsert(compIos, baseName);
    computeComponentIO(modelIo, compIo);
  }

  filterComponentIOs(compIos);

  // sort by I/O index in the model
  std::sort(compIos.begin(), compIos.end(), [] (const TComponentIOInfo& a, const
             TComponentIOInfo& b)
            {
            return a.m_data->m_index < b.m_data->m_index;
            }

            );
}

void ComponentClass::setStaticInstance()
{
  // allow only a single instance of the component
  // this limitation might be removed in a future version
  std::lock_guard<std::mutex> lck{ s_instanceMutex };

  if (s_instance == nullptr) {
    s_instance = this;
  } else if (s_instance != this) {
    Error(MAPSStreamedString() << "Only one instance of the [" << ComponentName <<
          "] model is allowed. "
          << "Only [" << s_instance->Name() << "] will be started.");
  }
}

void ComponentClass::clearStaticInstance()
{
  std::lock_guard<std::mutex> lck{ s_instanceMutex };

  if (s_instance == this) {
    s_instance = nullptr;
  }
}

void ComponentClass::Register()
{
  computeSkModelInputs ();
  computeSkModelOutputs();
  computeSkModelProps ();
  computeComponentIOs(s_skModelInputs , s_componentInputs );
  computeComponentIOs(s_skModelOutputs, s_componentOutputs);
}

void ComponentClass::Unregister()
{
}

ComponentClass::ComponentClass(const char* componentName,
  MAPSComponentDefinition& md)
  : MAPSComponent(componentName, md)
  , m_firstTime_Dynamic{ true }
{
}

ComponentClass::~ComponentClass()
{
  clearStaticInstance();
}

void ComponentClass::Dynamic()
{
  m_executionMode = static_cast<ExecMode>(GetIntegerProperty("executionMode"));
  createProperties();
  createInputs();
  createOutputs();
  m_firstTime_Dynamic = false;
}

void ComponentClass::createProperties()
{
  switch (m_executionMode)
  {
   case ExecMode::TriggeredByFirstInput:
    break;

   case ExecMode::Periodic:
   case ExecMode::PeriodicSamplingWhilePostProcessing:
    NewProperty("executionPeriod");
    DirectSet(Property("executionPeriod"), s_skModelStepSize);
    break;

   default:
    Error("Unsupported Execution Mode");
    break;
  }

  // Create properties for model params only if those exist
  if (!s_skModelParams.empty()) {
    createProperties_modelParams();
  }

  // Forcing the value of some inputs makes sense only if there are more than 1 input.
  // We need at least 1 (non-value-forced) input to implement the selected "executionMode"
  // Also, if "executionMode == Triggered", the trigger input is responsible for pacing the execution of the component
  // and its value cannot be forced.
  if (s_componentInputs.size() > 1) {
    createProperties_forcedInputValues();
  }
}

void ComponentClass::createProperties_modelParams()
{
  NewProperty("p_model_params_begin");
  for (const auto& paramInfo : s_skModelParams) {
    const std::string modelName = paramInfo.m_skTypeId == SkTypeId::t_bool ?
      "p_bool" : "p_string";
    const std::string propName =       /* std::string("p_") + */
      paramInfo.m_name;
    auto& prop = NewProperty(modelName.c_str(), propName.c_str());
    if (m_firstTime_Dynamic)
                    // init the value of the component prop from the model param
    {
      if (paramInfo.m_skTypeId == SkTypeId::t_bool) {
        const bool defaultValue = paramInfo.m_defaultValue == "1"
          || paramInfo.m_defaultValue == "true";
        DirectSet(prop, defaultValue);
      } else {
        DirectSet(prop, paramInfo.m_defaultValue.c_str());
      }
    } else       // assign to the value of the component prop to the model param
    {
      if (!paramInfo.m_writeToModelParam(prop)) {
        ReportError(MAPSStreamedString() <<
                    "Failed to set the value of parameter [" <<
                    paramInfo.m_name.c_str() << "]");
      }
    }
  }

  NewProperty("p_model_params_end");
}

void ComponentClass::createProperties_forcedInputValues()
{
  bool hasErrors = false;
  NewProperty("p_input_values_begin");
  size_t forcedInputCount = 0;

  // Forcing the value of the trigger input is not allowed (see Dynamic())
  const size_t firstInputIdx = (m_executionMode == ExecMode::
    TriggeredByFirstInput)
    ? 1
    : 0;
  for (size_t inputIdx = firstInputIdx; inputIdx < s_componentInputs.size();
       ++inputIdx) {
    auto& info = s_componentInputs[inputIdx];
    switch (info.m_typeId)
    {
     case TypeID(double ):
     case TypeID(float ):
     case TypeID(int8_t ):
     case TypeID(uint8_t ):
     case TypeID(int16_t ):
     case TypeID(uint16_t):
     case TypeID(int32_t ):
     case TypeID(uint32_t):
     case TypeID(int64_t ):
     case TypeID(uint64_t):
      {
        const std::string boolPropName = std::string{ "p_force_value_of_" } +
        info.m_name;

        const std::string valuePropName = std::string{ "p_value_of_" } +
        info.m_name;

        auto& forcedValue = info.m_forcedValue;
        auto& forcedVectorSize = info.m_forcedVectorSize;
        auto& boolProp = NewProperty("p_force_value_of_input",
          boolPropName.c_str());
        if (GetBoolProperty(boolProp)) {
          ++forcedInputCount;
          auto& valueProp = NewProperty("p_value_of_input", valuePropName.c_str());
          switch (info.m_typeId)
          {
           case TypeID(double ):
            forcedVectorSize = parseValues<double >((const char*)
              GetStringProperty(valueProp), forcedValue);
            break;

           case TypeID(float ):
            forcedVectorSize = parseValues<float >((const char*)
              GetStringProperty(valueProp), forcedValue);
            break;

           case TypeID(int8_t ):
            forcedVectorSize = parseValues<int8_t >((const char*)
              GetStringProperty(valueProp), forcedValue);
            break;

           case TypeID(uint8_t ):
            forcedVectorSize = parseValues<uint8_t >((const char*)
              GetStringProperty(valueProp), forcedValue);
            break;

           case TypeID(int16_t ):
            forcedVectorSize = parseValues<int16_t >((const char*)
              GetStringProperty(valueProp), forcedValue);
            break;

           case TypeID(uint16_t):
            forcedVectorSize = parseValues<uint16_t>((const char*)
              GetStringProperty(valueProp), forcedValue);
            break;

           case TypeID(int32_t ):
            forcedVectorSize = parseValues<int32_t >((const char*)
              GetStringProperty(valueProp), forcedValue);
            break;

           case TypeID(uint32_t):
            forcedVectorSize = parseValues<uint32_t>((const char*)
              GetStringProperty(valueProp), forcedValue);
            break;

           case TypeID(int64_t ):
            forcedVectorSize = parseValues<int64_t >((const char*)
              GetStringProperty(valueProp), forcedValue);
            break;

           case TypeID(uint64_t):
            forcedVectorSize = parseValues<uint64_t>((const char*)
              GetStringProperty(valueProp), forcedValue);
            break;

           default:
            break;
          }

          if (forcedValue.empty()) {
            hasErrors = true;
            ReportError(MAPSStreamedString() << valueProp.ShortName() <<
                        ": Failed to parse the value of input [" <<
                        info.m_name.c_str() <<
                        "]. The valid format for this property is the following (without quotes) \"value_0 value_1 ... value_N\"");
          }
        } else {
          forcedValue.clear();
        }
        break;
      }

     case TypeID(IplImage):
      {
        // Default value for IplImage inputs is not supported
        break;
      }

     case TypeID(Struct_t):
      {
        // Default value for struct inputs is not supported
        break;
      }

     default:
      hasErrors = true;
      MAPS::ReportError(MAPSStreamedString() << MAPS_FUNCTION_SIGNATURE <<
                        ": Unsupported Input Type [type_id:" << info.m_typeId <<
                        "]");
    }
  }

  NewProperty("p_input_values_end");

  // Check that we have at least one input that can be used with the InputReader
  if (forcedInputCount >= s_componentInputs.size()) {
    hasErrors = true;
    ReportError("Can't force the value of all inputs. At least 1 input value must be NOT forced.");
  }

  if (hasErrors) {
    ReportError("Errors in component configuration. Refer to the previous error messages for more information.");
    SetErrorState(true);
  }
}

void ComponentClass::createInputs()
{
  m_inputMap.clear();
  m_dataInputs.clear();
  m_forcedDataInputs.clear();
  const auto newInput = [this] (const std::string& readerType, const
    ComponentInputInfo& info)
  {
    const std::string inputModelName = std::string("i_") + readerType + "_" +
      getIOModelName(info);
    auto* input = &NewInput(inputModelName.c_str(), info.m_name.c_str());
    m_inputMap[input] = &info;
    if (!info.hasForcedValue()) {
      m_dataInputs.emplace_back(input);
    } else {
      m_forcedDataInputs.emplace_back(input);
    }
  }

  ;
  switch (m_executionMode)
  {
   case ExecMode::Periodic:
    for (const auto& info : s_componentInputs) {
      newInput("sampling", info);
    }
    break;

   case ExecMode::TriggeredByFirstInput:
    // trigger (it is also the 1st data input)
    {
      newInput("fifo", s_componentInputs.front());
    }

    // remaining data inputs
    for (size_t idx = 1; idx < s_componentInputs.size(); ++idx) {
      newInput("sampling", s_componentInputs[idx]);
    }
    break;

   case ExecMode::PeriodicSamplingWhilePostProcessing:
    for (const auto& info : s_componentInputs) {
      newInput("fifo", info);
    }
    break;

   default:
    Error("Unsupported Execution Mode");
    break;
  }
}

void ComponentClass::createOutputs()
{
  m_outputMap.clear();
  m_dataOutputs.clear();
  for (const auto& info : s_componentOutputs) {
    const std::string outputModelName = std::string("o_") + getIOModelName(info);
    auto* output = &NewOutput(outputModelName.c_str(), info.m_name.c_str());
    m_outputMap[output] = &info;
    m_dataOutputs.push_back(output);
  }
}

void ComponentClass::allocOutputBuffers_birth()
{
  for (auto* output : m_dataOutputs) {
    const auto& info = *m_outputMap.at(output);
    std::ostringstream oss;
    switch (info.m_typeId)
    {
     case TypeID(double ):
     case TypeID(float ):
     case TypeID(int8_t ):
     case TypeID(uint8_t ):
     case TypeID(int16_t ):
     case TypeID(uint16_t):
     case TypeID(int32_t ):
     case TypeID(uint32_t):
     case TypeID(int64_t ):
     case TypeID(uint64_t):
      {
        oss << "AllocOutputBuffer: " << info.m_name << ": " <<
          info.m_data->m_width << " elements";
        ReportInfo(oss.str().c_str());
        output->AllocOutputBuffer(info.m_data->m_width);
        break;
      }

     case TypeID(IplImage):
      {
        oss << "AllocOutputBuffer: " << info.m_name << ": deferred";
        ReportInfo(oss.str().c_str());
        break;
      }

     case TypeID(Struct_t):
      {
        const int sizeOfOutput = info.m_data->m_width *
          info.m_data->m_sizeOfType;
        oss << "AllocOutputBuffer: " << info.m_name << ": " <<
          info.m_data->m_width << " elements x " << info.m_data->m_sizeOfType <<
          " bytes per element = " << sizeOfOutput << " bytes";
        ReportInfo(oss.str().c_str());
        output->AllocOutputBuffer(sizeOfOutput);
        break;
      }

     default:
      MAPS::ReportError(MAPSStreamedString() <<
                        "AllocOutputBuffer: Unsupported Output Type [output_name:"
                        << info.m_name.c_str() << "] [type_id:" << info.m_typeId
                        << "]");
      throw MAPS::ErrorException;
    }
  }
}

void ComponentClass::allocOutputBuffers_deferred()
{
  if (m_deferredBuffersAllocated) {
    return;
  }

  for (auto& kv : m_outputMap) {
    auto& output = *kv.first;
    auto& info = *kv.second;
    switch (info.m_typeId)
    {
     case TypeID(IplImage):
      {
        int32_t imageSize[2];
        char chSeq[4 + 1];            // +1 == '\0' for printing in ReportInfo()
        const int32_t dataOrder = IPL_DATA_ORDER_PLANE;
        const int32_t depth = IPL_DEPTH_8U;

        //const int32_t align = IPL_ALIGN_QWORD;
        const auto& imageInfo = info.m_imageInfo;
        imageInfo.m_size ->m_readFromModelOutput(TypeID(int32_t), imageSize , 2);
        imageInfo.m_channelSeq->m_readFromModelOutput(TypeID(int8_t ), chSeq , 4);
        chSeq[4] = '\0';

        //imageInfo.m_dataOrder ->m_readFromModelOutput(TypeID(int32_t), &dataOrder, 1);
        //imageInfo.m_depth     ->m_readFromModelOutput(TypeID(int32_t), &depth    , 1);
        //imageInfo.m_align     ->m_readFromModelOutput(TypeID(int32_t), &align    , 1);

        // In Matlab, size(someMatrix) = [rows cols] = [height width]
        // that is why we use the same convention here
        const auto imageHeight = imageSize[0];
        const auto imageWidth = imageSize[1];
        std::ostringstream oss;
        oss << "AllocOutputBuffer: " << info.m_name << " [width:" << imageWidth <<
          "] [height:" << imageHeight << "] [channel_seq:" << chSeq << "]";
        ReportInfo(oss.str().c_str());
        const auto imageModel = MAPS::IplImageModel(imageWidth, imageHeight,
          chSeq, dataOrder, depth      /*, align*/
          );
        output.AllocOutputBufferIplImage(imageModel);
        break;
      }

      // int, float, bool: allocated at birth
     default:
      break;
    }
  }

  m_deferredBuffersAllocated = true;
}

void ComponentClass::Birth()
{
  setStaticInstance();
  m_deferredBuffersAllocated = false;
  allocOutputBuffers_birth();
  initSkModel();
  createInputReader();
}

void ComponentClass::Core()
{
  m_inputReader->Read();
}

void ComponentClass::Death()
{
  m_inputReader.reset();
  terminateSkModel();
  clearStaticInstance();
}

void ComponentClass::initSkModel()
{
  Path_Planner_initialize();
}

void ComponentClass::doSkModelStep()
{
  Path_Planner_step();

  /* Get model outputs here */
}

void ComponentClass::terminateSkModel()
{
  Path_Planner_terminate();
}

void ComponentClass::createInputReader()
{
  switch (m_executionMode)
  {
   case ExecMode::Periodic:
    m_inputReader = MAPS::MakeInputReader::PeriodicSampling(
      this,
      s_skModelStepSize,
      m_dataInputs,
      &ComponentClass::processData
      );
    break;

   case ExecMode::TriggeredByFirstInput:
    m_inputReader = MAPS::MakeInputReader::Triggered(
      this,
      *m_dataInputs.front(),
      MAPS::InputReaderOption::Triggered::TriggerKind::DataInput,
      MAPS::InputReaderOption::Triggered::SamplingBehavior::WaitForAllInputs,
      m_dataInputs,
      &ComponentClass::processData
      );
    break;

   case ExecMode::PeriodicSamplingWhilePostProcessing:
    m_inputReader = MAPS::MakeInputReader::PeriodicSamplingBasedOnTimestamps(
      this,
      s_skModelStepSize,
      m_dataInputs,
      &ComponentClass::processData
      );
    break;

   default:
    Error("Unsupported reading policy");
    break;
  }
}

void ComponentClass::processData(const MAPSTimestamp ts, MAPS::ArrayView<MAPS::
  InputElt<>> inElts)
{
  readInputs(ts, inElts);
  readForcedInputs(ts);
  doSkModelStep();
  allocOutputBuffers_deferred();
  writeOutputs(ts);
}

void ComponentClass::readInputs(const MAPSTimestamp /*ts*/
  , const MAPS::ArrayView<MAPS::InputElt<>>& inElts)
{
  for (auto& inElt : inElts) {
    auto* input = inElt.Input();
    auto& info = m_inputMap.at(input);
    readInput(inElt, *info);
  }
}

void ComponentClass::readInput(const MAPS::InputElt<>& inElt, const
  ComponentInputInfo& info)
{
  int32_t vectorSizeValue = static_cast<int32_t>(inElt.VectorSize());
  switch (info.m_typeId)
  {
   case TypeID(IplImage):
    {
      const auto& data = inElt.DataAs<IplImage>();
      const int height = data.height;
      const int width = data.width;
      const int widthStep = data.widthStep;
      const auto* mapsImageData = reinterpret_cast<const uint8_t*>
        (data.imageData);
      auto* skImageData = static_cast<uint8_t*>(info.m_data->m_dataPtr);

      //info.m_data->m_writeToModelInput(TypeID(uint8_t), data.imageDataOrigin, data.imageSize);

      // Copy the input image to column-major, unaligned matrix as expected by Matlab
      for (int channelIdx = 0; channelIdx < data.nChannels; ++channelIdx) {
        RowMajorMatrixView<const uint8_t> rowMajorAlignedData(mapsImageData +
          (height * widthStep * channelIdx), height, widthStep);
        ColMajorMatrixView<uint8_t> colMajorUnalignedData(skImageData + (height *
          width * channelIdx), height, width);
        for (int row = 0; row < height; ++row) {
          for (int col = 0; col < width; ++col) {
            colMajorUnalignedData(row, col) = rowMajorAlignedData(row, col);
          }
        }
      }

      auto& imageInfo = info.m_imageInfo;

      // In Matlab, size(someMatrix) = [rows cols] = [height width]
      // that is why we use the same convention here
      const int32_t imageSize[2] = { height, width };

      imageInfo.m_size ->m_writeToModelInput(TypeID(int32_t), imageSize , 2);
      imageInfo.m_channelSeq->m_writeToModelInput(TypeID(int8_t) ,
        data.channelSeq, 4);

      //imageInfo.m_dataOrder ->m_writeToModelInput(TypeID(int32_t), &data.dataOrder, 1);
      //imageInfo.m_depth     ->m_writeToModelInput(TypeID(int32_t), &data.depth    , 1);
      //imageInfo.m_align     ->m_writeToModelInput(TypeID(int32_t), &data.align    , 1);
      break;
    }

   case TypeID(Struct_t):
    {
      vectorSizeValue /= info.m_data->m_sizeOfType;
      info.m_data->m_writeToModelInput(info.m_typeId, inElt.DataPointer(),
        vectorSizeValue);
      break;
    }

    // int, float, bool
   default:
    {
      info.m_data->m_writeToModelInput(info.m_typeId, inElt.DataPointer(),
        vectorSizeValue);
      break;
    }
  }

  writeToModelInput(info.m_vectorSize, vectorSizeValue);
  writeToModelInput(info.m_timestamp , inElt.Timestamp());
  writeToModelInput(info.m_frequency , inElt.Frequency());
  writeToModelInput(info.m_quality , inElt.Quality());
  writeToModelInput(info.m_misc1 , inElt.Misc1());
  writeToModelInput(info.m_misc2 , inElt.Misc2());
  writeToModelInput(info.m_misc3 , inElt.Misc3());
}

void ComponentClass::readForcedInputs(const MAPSTimestamp ts)
{
  for (MAPSInput* input : m_forcedDataInputs) {
    auto& info = m_inputMap.at(input);
    readForcedInput(ts, *info);
  }
}

void ComponentClass::readForcedInput(const MAPSTimestamp ts, const
  ComponentInputInfo& info)
{
  const int32_t vectorSizeValue = static_cast<int32_t>(info.m_forcedVectorSize);
  switch (info.m_typeId)
  {
   case TypeID(IplImage):
    {
      // Not supported
      break;
    }

   case TypeID(Struct_t):
    {
      // Not supported
      break;
    }

    // int, float, bool
   default:
    {
      info.m_data->m_writeToModelInput(info.m_typeId, info.m_forcedValue.data(),
        vectorSizeValue);
      break;
    }
  }

  writeToModelInput(info.m_vectorSize, vectorSizeValue);
  writeToModelInput(info.m_timestamp , ts);
  writeToModelInput(info.m_frequency , static_cast<int64_t>(0));
  writeToModelInput(info.m_quality , static_cast<int32_t>(0));
  writeToModelInput(info.m_misc1 , static_cast<int32_t>(0));
  writeToModelInput(info.m_misc2 , static_cast<int32_t>(0));
  writeToModelInput(info.m_misc3 , static_cast<int32_t>(0));
}

void ComponentClass::writeOutputs(const MAPSTimestamp ts)
{
  for (auto& kv : m_outputMap) {
    MAPS::OutputGuard<> outGuard(this, *kv.first, true);
    writeOutput(ts, outGuard, *kv.second);
    outGuard.Validate();
  }
}

void ComponentClass::writeOutput(const MAPSTimestamp ts, MAPS::OutputGuard<>
  & outGuard, const ComponentOutputInfo& info)
{
  int32_t vectorSizeValue = 0;
        // newer versions of OutputGuard::VectorSize() return a size_t_reference
  readFromModelOutput(info.m_vectorSize, vectorSizeValue, info.m_data->m_width);

  // disable warning for older versions of OutputGuard::VectorSize() which return MAPSInt32&
#ifdef _MSC_VER

#pragma warning(push)
#pragma warning(disable:4267)
#pragma warning(disable:4365)

#else

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wconversion"

#endif

  outGuard.VectorSize() = static_cast<size_t>(vectorSizeValue);

#ifdef _MSC_VER

#pragma warning(pop)

#else

#pragma GCC diagnostic pop

#endif

  readFromModelOutput(info.m_timestamp , outGuard.Timestamp (), ts);
  readFromModelOutput(info.m_frequency , outGuard.Frequency (), 0);
  readFromModelOutput(info.m_quality , outGuard.Quality (), 0);
  readFromModelOutput(info.m_misc1 , outGuard.Misc1 (), 0);
  readFromModelOutput(info.m_misc2 , outGuard.Misc2 (), 0);
  readFromModelOutput(info.m_misc3 , outGuard.Misc3 (), 0);
  if (outGuard.VectorSize() < 0) {
    std::ostringstream oss;
    oss << info.m_name << G_IO_SUFFIX_VECTOR_SIZE << " [" << outGuard.VectorSize
      () << "] < 0. Setting it to 0 and moving on...";
    ReportError(oss.str().c_str());
    outGuard.VectorSize() = 0;
    return;
  }

  switch (info.m_typeId)
  {
   case TypeID(IplImage):
    {
      auto& data = outGuard.DataAs<IplImage>();
      const int height = data.height;
      const int width = data.width;
      const int widthStep = data.widthStep;

      //info.m_data->m_readFromModelOutput(TypeID(uint8_t), data.imageDataOrigin, data.imageSize);
      auto* mapsImageData = reinterpret_cast<uint8_t*>(data.imageData);
      const auto* skImageData = static_cast<const uint8_t*>
        (info.m_data->m_dataPtr);

      // Copy the input image from the Matlab, column-major, unaligned matrix
      for (int channelIdx = 0; channelIdx < data.nChannels; ++channelIdx) {
        RowMajorMatrixView<uint8_t> rowMajorAlignedData(mapsImageData + (height *
          widthStep * channelIdx), height, widthStep);
        ColMajorMatrixView<const uint8_t> colMajorUnalignedData(skImageData +
          (height * width * channelIdx), height, width);
        for (int row = 0; row < height; ++row) {
          for (int col = 0; col < width; ++col) {
            rowMajorAlignedData(row, col) = colMajorUnalignedData(row, col);
          }
        }
      }

      outGuard.VectorSize() = 0;
                    // By convention: the vector size of an IplImage output is 0
      break;
    }

   case TypeID(Struct_t):
    {
      info.m_data->m_readFromModelOutput(info.m_typeId, outGuard.DataPointer(),
        outGuard.VectorSize());

      // disable warning for older versions of OutputGuard::VectorSize() which return MAPSInt32&
#ifdef _MSC_VER

#pragma warning(push)
#pragma warning(disable:4267)
#pragma warning(disable:4365)

#else

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wconversion"

#endif

      outGuard.VectorSize() = static_cast<size_t>(vectorSizeValue *
        info.m_data->m_sizeOfType);

#ifdef _MSC_VER

#pragma warning(pop)

#else

#pragma GCC diagnostic pop

#endif

      break;
    }

    // int, float, bool
   default:
    {
      info.m_data->m_readFromModelOutput(info.m_typeId, outGuard.DataPointer(),
        outGuard.VectorSize());
      break;
    }
  }
}
